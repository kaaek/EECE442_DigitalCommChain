% ----------------------------------------------------------------------
% authors: Khalil El Kaaki, Mouhammad Kandakji
% 
% Note on the use of AI:
% * Copilot wrote the help sections for our functions
%       (the big comment blocks following function declarations)
% * ChatGPT only corrected minor logical and syntax errors.
% ----------------------------------------------------------------------

% ----------------------------------------------------------------------
% authors: Khalil El Kaaki, Mouhammad Kandakji
%
% Note on the use of AI:
% * Copilot wrote the help sections for our functions
%       (the big comment blocks following function declarations)
% * ChatGPT only corrected minor logical and syntax errors.
% ----------------------------------------------------------------------

function baseline_huffman_analysis(X, OPTS)
% BASELINE_HUFFMAN_ANALYSIS  Symbol-wise baseline Huffman coding demo
%
% This script mirrors the structure/style of sampling_analysis.m:
%  - Prints a header indicating the section is running
%  - Normalizes/validates inputs
%  - Calls baseline_huffman_V2 (our reference implementation)
%  - Produces tidy, comparable plots (3 stacked subplots)
%  - Prints a concise, report-ready summary
%
% Inputs:
%   X     : vector of discrete symbols (numeric, char, or strings)
%   OPTS  : (optional) struct with fields:
%           - A_design : designed alphabet (cell/char/string/numeric)
%           - notes    : arbitrary metadata to attach in the result
%
% Behavior:
%   Uses observed PMF to build a symbol-wise Huffman dictionary.
%   Compares against fixed-length baseline based on |A_design|.
%   Draws probability and code-length diagnostics analogous to your
%   plot style in sampling_analysis.m.
%
% Outputs:
%   Printed dictionary (from baseline_huffman_V2), figures, and
%   a summary of entropy, rates, and compression gains.
%
% Example:
%   S = "HELLO_HELLO_WORLD!!!";
%   baseline_huffman_analysis(S);
%
% Requirements:
%   - baseline_huffman_V2.m must be on MATLAB path.

fprintf('========================================\n');
fprintf('   3.2 Baseline Huffman is Running...\n');
fprintf('========================================\n');

% ---------- normalize input (mirror style from your baseline) ----------
if isnumeric(X)
    Xn = string(X(:));
elseif ischar(X) || isstring(X)
    Xn = string(X(:));
else
    error('X must be numeric, char, or string.');
end

if nargin < 2
    OPTS = struct();
end

% ---------- run the baseline reference implementation ----------
R = baseline_huffman_V2(Xn, OPTS);

% ---------- pull fields for quick access ----------
A_obs   = R.A_observed;
tbl     = R.dict_table;          % Symbol | Probability | Code | Len
H       = R.entropy_bits_per_symbol;
Lfix    = R.fixed_bits_per_symbol;
Lhuff   = R.huffman_avg_bits_per_symbol;
N       = R.N;

% ---------- Plot diagnostics (3 stacked like your sampling figure) ----------
figure('Name','Baseline Huffman Diagnostics','Color','w');

% (1) Probability bar (sorted)
subplot(3,1,1);
[p_sorted, ord] = sort(tbl.Probability, 'descend');
sym_sorted      = string(tbl.Symbol(ord));
bar(p_sorted, 'DisplayName','p(a)'); grid on; hold on;
xlabel('Symbol (sorted)'); ylabel('p(a)');
title('Observed PMF (sorted by probability)');
xticks(1:numel(sym_sorted));
xticklabels(sym_sorted);
xtickangle(45);
legend show;

% (2) Code length bar aligned with the same order
subplot(3,1,2);
len_sorted = tbl.Len(ord);
bar(len_sorted, 'DisplayName','\ell(a)'); grid on; hold on;
xlabel('Symbol (sorted)'); ylabel('bits');
title('Huffman Code Lengths \ell(a) (aligned with PMF order)');
xticks(1:numel(sym_sorted));
xticklabels(sym_sorted);
xtickangle(45);
legend show;

% (3) Scatter p vs length with Shannon ideal overlay -log2 p
subplot(3,1,3);
scatter(p_sorted, len_sorted, 36, 'filled', 'DisplayName','Huffman \ell(a)'); hold on; grid on;
ideal = -log2(max(p_sorted, eps));
plot(p_sorted, ideal, 'k--', 'DisplayName','Shannon bound -log_2 p(a)', 'LineWidth',1.2);
xlabel('p(a)'); ylabel('bits');
title('Code Optimality Check: \ell(a) vs -log_2 p(a)');
legend show;

% ---------- High-level summary (like your MSE print) ----------
fprintf('\nBaseline Huffman Report (symbol-wise):\n');
fprintf('--------------------------------------\n');
fprintf('N (number of symbols)       : %d\n', N);
fprintf('|A_observed| / |A_design|   : %d / %d\n', numel(A_obs), numel(R.A_design));
fprintf('Entropy H(A)                : %.4f bits/sym\n', H);
fprintf('Fixed length (design)       : %d bits/sym (total %d)\n', Lfix, R.total_bits_fixed);
fprintf('Huffman avg length          : %.4f bits/sym (total %d)\n', Lhuff, R.total_bits_huffman);
fprintf('Compression vs fixed        : %.2f%%\n', 100*R.compression_gain_vs_fixed);
fprintf('Lossless verified           : %d\n', R.lossless_verified);

% ---------- Optional: tiny table preview in Command Window ----------
try
    % Show top-k by probability (k ≤ 12 for readability)
    k = min(12, height(tbl));
    previewTbl = tbl(ord(1:k), :);
    disp('Top symbols by probability (preview):');
    disp(previewTbl);
catch
    % ignore
end

% ---------- TO-DO (report pointers) ----------
% * Comment on why Huffman lengths track -log2 p(a) and why \ell(a) ≥ H(A).
% * Explain the role of |A_design| in the fixed-length baseline.
% * If needed, discuss effect of alphabet skew on compression gain.
% * (Optional) Add cumulative bit-count plot for streaming scenarios.

end
